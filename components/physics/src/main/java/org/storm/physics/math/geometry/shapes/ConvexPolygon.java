package org.storm.physics.math.geometry.shapes;

import lombok.Getter;
import org.apache.commons.math3.util.FastMath;
import org.storm.core.render.Renderable;
import org.storm.physics.math.Interval;
import org.storm.physics.math.Vector;
import org.storm.physics.math.geometry.LineSegment;
import org.storm.physics.math.geometry.Point;
import org.storm.physics.transforms.UnitConvertor;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * A ConvexPolygon represents a mathematical convex polygon with N vertices in 2D space. Vertices are supplied in clockwise
 * order and edges are generated by following such order (i.e. (v_i, v_i+1) is an edge)
 *
 * Potentially might want to update the internal implementation here to use a Circularly Doubly Linked List for the vertices
 * and edges.
 */
@Getter
public class ConvexPolygon implements Shape {

  private static final double RAY_CASTING_EPSILON = 0.00001;

  protected final List<Point> vertices;

  protected final List<LineSegment> edges;

  protected final Point center;

  public ConvexPolygon(Point... vertices) {
    // Order matters here!!
    this.vertices = Arrays.stream(vertices)
      .distinct()
      .collect(Collectors.toList());

    if (this.vertices.size() <= 2) {
      throw new IllegalArgumentException("a polygon must have a minimum of 3 distinct vertices");
    }

    this.edges = this.findEdges();
    this.center = this.findCenter();
  }

  /**
   * @param p point to check against
   * @return the vertex (Point) of the ConvexPolygon which is closest to p
   */
  public Point getClosestVertex(Point p) {
    double min = Double.POSITIVE_INFINITY;
    Point nearest = this.vertices.get(0);

    for (Point v : this.vertices) {
      double d = p.getSquaredDistance(v);
      if (d < min) {
        min = d;
        nearest = v;
      }
    }

    return nearest;
  }

  @Override
  public void translate(double dx, double dy) {
    this.vertices
      .parallelStream()
      .forEach(point -> point.translate(dx, dy));
    this.getEdges()
      .parallelStream()
      .forEach(edge -> edge.translate(dx, dy));
    this.getCenter().translate(dx, dy);
  }

  /**
   * Returns the projection of this Polygon onto the given axis
   *
   * The projection of a Polygon on a given axis is the 1d line segment (or interval)
   * [A, B] where A = min dot product between the axis and the vertices of the polygon
   * and B = max dot product between the axis and the vertices of the polygon
   *
   * @param axis the vector axis to project onto
   * @return Interval representing the projection
   */
  @Override
  public Interval getProjection(Vector axis) {
    List<Vector> vectorVertices = this.vertices
      .stream()
      .map(Point::toVector)
      .collect(Collectors.toList());

    double min = Double.POSITIVE_INFINITY;
    double max = 0.0;

    for (Vector v : vectorVertices) {
      double d = axis.dot(v);
      if (d < min) min = d;
      if (d > max) max = d;
    }

    return new Interval(min, max);
  }

  /**
   * An implementation of contains for a generic polygon using the Ray Casting Algorithm
   *
   * @param p Point to check
   * @return true if p is contained within the convex polygon
   */
  @Override
  public boolean contains(Point p) {
    int totalIntersections = this.edges
      .stream()
      .filter(edge -> edge.getStart().getY() != edge.getEnd().getY()) //  Only look for non horizontal edges
      .map(edge -> this.castRay(p, edge))
      .reduce(0, Integer::sum);

    return (totalIntersections & 1) != 0; // Check if odd
  }

  @Override
  public Renderable transform(UnitConvertor unitConvertor) {
    return (gc, x, y) -> {
      int vertexCount = this.vertices.size();
      double[] xCoordinates = new double[vertexCount];
      double[] yCoordinates = new double[vertexCount];

      IntStream.range(0, vertexCount)
        .forEach(i -> {
          Point vertex = this.vertices.get(i);
          xCoordinates[i] = unitConvertor.toPixels(vertex.getX());
          yCoordinates[i] = unitConvertor.toPixels(vertex.getY());
        });

      gc.fillPolygon(xCoordinates, yCoordinates, vertexCount);
    };
  }

  @Override
  public String toString() {
    return String.format("Points: %s", this.vertices);
  }

  /**
   * Returns the edges of the polygon as vectors. The edges are defined as such:
   *
   * e_i = <v_i, v_{i+1}> and e_{\V\} = <v_\V\, v_0> where v_i is the ith vertex of the polygon.
   *
   * @return the edges of the polygon
   */
  protected List<LineSegment> findEdges() {
    List<LineSegment> polygonEdges = new ArrayList<>();

    for (int i = 0; i < this.vertices.size() - 1; i++) {
      polygonEdges.add(new LineSegment(this.vertices.get(i), this.vertices.get(i + 1)));
    }

    polygonEdges.add(new LineSegment(this.vertices.get(this.vertices.size() - 1), this.vertices.get(0)));

    return polygonEdges;
  }

  /**
   * @return calculates and returns the center of a generic ConvexPolygon
   */
  protected Point findCenter() {
    double xNumerator = 0;
    double yNumerator = 0;
    double denominator = 0;

    int vertexCount = this.vertices.size();
    for (int i = 0; i < vertexCount; i++) {
      Point current = this.vertices.get(i);
      Point neighbour = (i == vertexCount - 1) ? this.vertices.get(0) : this.vertices.get(i + 1);

      // Calculate the determinant of the follow 2x2 matrix
      // [a b] = [current.x    current.y]
      // [c d] = [neighbour.x  neighbour.y]
      // --> ad - bc = current.x * neighbour.y - current.y * neighbour.x
      double det = current.getX() * neighbour.getY() - current.getY() * neighbour.getX();

      xNumerator += (current.getX() + neighbour.getX()) * det;
      yNumerator += (current.getY() + neighbour.getY()) * det;
      denominator += det;
    }

    return new Point(xNumerator / (3 * denominator), yNumerator / (3 * denominator));

  }

  /**
   * @param point Point to ray cast
   * @param edge edge (LineSegment) to check against
   * @return 1 iff the ray cast of the given point passes through the given edge, 0 otherwise
   */
  private int castRay(Point point, LineSegment edge) {
    Point higher = (edge.getEnd().getY() > edge.getStart().getY()) ? edge.getEnd() : edge.getStart();
    Point lower = (edge.getEnd().getY() > edge.getStart().getY()) ? edge.getStart() : edge.getEnd();

    // Considering "on vertex" case
    if (point.getY() == higher.getY() || point.getY() == lower.getY()) {
      point = new Point(point.getX(), point.getY() + RAY_CASTING_EPSILON);
    }

    if (point.getY() > higher.getY()
      || point.getY() < lower.getY()
      || point.getX() > FastMath.max(higher.getX(), lower.getX())) return 0;

    if (point.getX() < FastMath.min(higher.getX(), lower.getX())) return 1;

    // dividing a double by 0 --> INFINITY
    double higherLowerSlope = (higher.getY() - lower.getY()) / (higher.getX() - lower.getX());
    double startLowerSlope = (point.getY() - lower.getY()) / (point.getX() - lower.getX());

    return startLowerSlope >= higherLowerSlope ? 1 : 0;
  }

}
